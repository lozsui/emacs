* Docker
** Installing on Ubuntu
snap install docker
snap info docker
** Getting Started
*** Getting Started by Docker
https://docs.docker.com/get-started/
*** Hello Django
**** Image und Container erstellen
#+BEGIN_SRC
cd ~/004-Docker
mkdir Hello-Django
touch Dockerfile
touch requirements.txt
touch docker-compose.yml
#+END_SRC

Dockerfile:
#+BEGIN_SRC
FROM python:3.8-alpine

ENV PYTHONUNBUFFERED 1

COPY ./requirements.txt /requirements.txt
RUN pip install -r /requirements.txt

RUN mkdir /app
WORKDIR /app

RUN adduser -D shb
RUN chown shb:shb -R /app/
RUN chmod +x /app
USER shb
#+END_SRC

requirements.txt:
#+BEGIN_SRC
django == 2.2.17
django-extensions == 3.0.2
#+END_SRC

docker-compose.yml:
#+BEGIN_SRC
version: "3"

services:
    app:
        build:
            context: .
        ports:
            - "8000:8000"
        volumes:
            - ./app:/app
        command: >
            sh -c "python manage.py runserver 0.0.0.0:8000"
#+END_SRC

#+BEGIN_SRC
sudo docker build -t hello-django .
mkdir app
sudo docker run --rm -v "${PWD}:/app" hello-django django-admin startproject demo app
sudo docker run --rm -v "${PWD}:/app" -e DJANGO_MANAGEMENT_JOB=makemigrations hello-django
sudo docker-compose up
curl localhost:8000 | grep "The install worked successfully! Congratulations!"
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 16348  100 16348    0     0   498k      0 --:--:-- --:--:-- --:--:--  514k
        <h2>The install worked successfully! Congratulations!</h2>
#+END_SRC

Es gibt nun einen Container hello-django_app
#+BEGIN_SRC
sudo docker container ls -a
#+END_SRC

Es gibt nun ein Image hello-django
#+BEGIN_SRC
sudo docker image ls
#+END_SRC

So ist es.
**** Container ausführen
#+BEGIN_SRC bash
cd /home/shb/004-Docker/Hello-Django
sudo docker-compose up
#+END_SRC
** Commands
*** Working with Containers
Start a container
#+BEGIN_SRC bash
docker start 3b2e7f1f792b
#+END_SRC

where 3b2e7f1f792b is CONTAINER-ID

List all running containers
#+BEGIN_SRC bash
docker ps
#+END_SRC

List all containers
#+BEGIN_SRC bash
docker ps -a
#+END_SRC

List all Containers
#+BEGIN_SRC bash
docker container ls -a
#+END_SRC

Running in Detached (-d) Mode
#+BEGIN_SRC bash
docker container run -d --name mongo mongo
#+END_SRC

See logs of Container
#+BEGIN_SRC bash
docker container logs mongo
#+END_SRC

Stop Container
#+BEGIN_SRC bash
docker container stop mongo
#+END_SRC

Remove a Container
#+BEGIN_SRC bash
docker container rm mongo
#+END_SRC

Remove running Container
#+BEGIN_SRC bash
docker container rm -f mongo
#+END_SRC

Publish (-p) a Service (1): Service hört auf 8081 extern und auf 27017
intern.
#+BEGIN_SRC bash
docker container run -d --name mongo -p 8081:27017 mongo
#+END_SRC

Attach to the container again
#+BEGIN_SRC bash
sudo docker attach 51
#+END_SRC

where 51 is the beginning of the container-id of the container we want
to attach to.

Publish (-p) a Service (2): Auf diese Weise wählt Docker, mit welchem
Port ein Service publiziert wird.
#+BEGIN_SRC bash
docker container run -d --name mongo -p 27017 mongo
#+END_SRC

Inspect a Container
#+BEGIN_SRC bash
docker container inspect mongo
#+END_SRC
*** Working with Images
List images
#+BEGIN_SRC bash
sudo docker image ls
#+END_SRC

Build an Image: Kommando unten schaut sich Dockerfile im Current
Working Directory an und erstellt auf Basis dieses Dockerfiles ein
Image.
#+BEGIN_SRC bash
sudo docker image build -t my-name:my-tag .
#+END_SRC

Pull from Docker-Hub
#+BEGIN_SRC bash
sudo docker pull debian:10-slim
#+END_SRC

Remove Image
#+BEGIN_SRC bash
sudo docker image rm 18e588cc27a6
#+END_SRC

Remove Image (shorthand)
#+BEGIN_SRC bash
sudo docker rmi 18e588cc27a6
#+END_SRC

Remove all dangling images
#+BEGIN_SRC bash
sudo docker image prune
#+END_SRC
* Kryptographie und Sicherheit
** WAF (Web Application Firewall)
** PKI (Public Key Infrastructure)
- Über die PKI können öffentliche Schlüssel verteilt werden.
*** X.509
- X.509 ist ein Format für Zertifikate
*** Public Key / Private Key
- Ein Public Key kann verwendet werden, um jemanden eine
  verschlüsselte Nachricht zu senden. Nur der Empfänger kennt den
  Private Key, mit welchem die verschlüsselte Nachricht wieder
  entschlüsselt werden kann.
- Der Public Key wird mit dem Private Key erstellt.
*** CRL (Certificate Revocation List)
- CA erstellt die CRL.
- Auf der CRL kann man gucken, ob ein Zertifikat, welches man
  beispielsweise von "boeser.ch" erhalten hat, gültig ist.
- Zertifikate können geklaut werden. In einem solchen Falle ist es
  wichtig, dass informiert werden kann, dass das "geklaute" Zertifikat
  nicht mehr gültig ist.
*** CA (Certificate Authority)
- CA stellt sicher, dass ein Zertifikat "boeser.ch" tatsächlich an den
  Eigentümer von "boeser.ch" vergeben wurde.
- CA bestätigt die Identität eines Public Keys indem sie diesen mit
  ihrem Private Key signiert.
** Steganography
- Beispielsweise hinterlegen einer geheimen Nachricht in einem Bild.
- Steganography wird auch Banknoten verwendet, um diese vor Fälschung
  zu schützen.
** Key Escrow
- Im Key Escrow werden private und geheime Schlüssel hinterlegt, damit
  diese im Desaster-Fall nicht verloren gehen.
** Hashing
- Hashing ist eine Funktion, welche einen Text in einen Text fixer
  Länge überführt.
- Mittels Hashing kann überprüft werden ob ein Text verändert wurde.
- Im Kontext des Hashings bedeutet eine Kollision, dass zwei
  verschiedene Texte denselben Hash-Wert haben.
** Non-repudiation
- Non-repudiation ermöglicht zwei Dinge: Erstens hat der Sender
  Gewähr, dass seine Nachricht beim Empfänger eingetroffen
  ist. Zweitens hat der Empfänger Gewähr, dass die Nachricht
  tatsächlich vom Sender stammt.
** Symmetrische und Asymetrische Verschlüsselung
- Bei der symmetrischen Verschlüsselung wird zum Verschlüsseln und
  Entschlüsseln ein Schlüssel verwendet.
- Zum Zeitpunkt, wo diese Zeilen hier geschrieben werden
  (19. Juli 2021) wird ein symmetrischer Schlüssel mit einer Länge von
  128 Bit als sicher betrachtet.
- Bei der asymmetrischen Verschlüsselung gibt es zwei Schlüssel. Einen
  öffentlichen und einen privaten. Mit dem öffentlichen Schlüssel wird
  verschlüsselt, mit dem privaten Schlüssel wird entschlüsselt.
- Das Pendant zu einem symmetrischen 128-Bit-Schlüssel in Bezug auf
  Sicherheit ist ein asymmetrischer 3248-Bit-Schlüssel.
** Block- und Stream-Verschlüsselung
- Bei der Block-Verschlüsselung werden Blöcke z.B. à 64-bit verschlüsselt.
- Bei der Stream-Verschlüsselung wird 'Bit by Bit' verschlüsselt.
** Transport-Verschlüsselung
*** VPN
*** TLS
- In einem gewsissen Sinne kann ein TLS-Zertifikat als Public Key und
  der TLS-Key als Private Key betrachtet werden.
- Um das TLS-Zertifikat von boeser.ch zu prüfen, vergleicht man die
  Signatur des TLS-Zertifikates mit der lokalen Signatur vom
  entsprechenden CA.
- Das TLS-Zertifikat eines Host wird vom Client verwendet, um
  verschlüsselte Nachrichten an den Host zu senden. Insbesondere
  werden auf diese Weise verschlüsselte Nachrichten ausgetauscht, um
  sich auf einen symmetrischen Schlüssel für die TLS-Session zu
  einigen.
- Ein Host hält eine Liste von Chiffrierungsverfahren (Ciphers)
  vor. Der Klient schaut sich die angeboten Chiffrierungsverfahren an
  und wählt dann eines für die Kommunikation mit dem Host aus.
*** SSH
*** S/MIME
** Literatur
- [[https://learning.oreilly.com/library/view/comptia-r-security-rapid/9780735668478/][CompTIA Security+ Rapid Review]]
- [[https://learning.oreilly.com/library/view/linux-hardening-in/9780134173337][Linux Hardening in Hostile Networks: Server Security from TLS to Tor]]
